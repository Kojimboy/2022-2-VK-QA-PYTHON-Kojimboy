## Домашнее задание №1: Базовые навыки работы с Selenium

#### Цель домашнего задания

  * Изучить минимальный набор знаний и навыков для работы с Selenium.
  * Научиться искать элементы с помощью Selenium и проводить с ними простые действия.

#### Задача
* Тестирование портала https://target-sandbox.my.com/
* Настроить окружение для запуска UI тестов, UI тесты должны запускаться через марк -m UI
* В качестве браузера используем Google Chrome версии **105.0.5195.19**. Устанавливаться драйвер должен через webdriver_manager.
* Необходимо передать в качестве входного аргумента pytest (в метод pytest_addoption) значение ```parser.addoption('--headless', action='store_true')```

#### Что было сделано:
* Настроено окружение для корректного запуска UI тестов:
  * добавлен марк -m UI
  * выбрана версия **105.0.5195.19** chromedriver 
  * добавлены входные аргументы в метод `pytest_addoption` 
  * настроены зависимости _requirements.txt_

* Написаны тесты:
  * Класс **TestValidLogin** c валидными параметрами на логин:
    * `test_valid_login` на корректную авторизацию
  * Класс **TestInvalidLogin** на некорректную авторизацию:
    * параметризованный `test_invalid_login` на некорректный ввод данных при попытке входа
    * параметризованный `test_unregister_user_login` на авторизацию незарегистрированных пользователей
  * Класс **TestLoggedInUser** c валидными параметрами логина на поведение авторизованного пользователя:
    *  `test_logout` на выход из аккаунта
    * параметризованный `test_edit_user_info` на редактирование контактной информации в профиле
    * параметризованный `test_page_transition` на переход между страницами портала
---
## Домашнее задание №2: Продвинутые навыки работы с Selenium

#### Цель домашнего задания

  * Научиться более продвинуто работать с элементами и действиями с браузером.
  * Изучение паттерна PageObject.
  * Научиться писать тесты под параллельный запуск Selenium.
  * Научиться формировать отчет о тестировании.

#### Задача
* Тестирование портала https://target-sandbox.my.com/
* UI тесты должны запускаться через марк -m UI
* В качестве браузера используем Google Chrome версии **105.0.5195.19**. Устанавливаться драйвер должен через webdriver_manager.
* Необходимо передать в качестве входного аргумента pytest (в метод pytest_addoption) значение ```parser.addoption('--headless', action='store_true')``` (как в первой ДЗ)
* Необходимо реализовать фикстуру, которая будет сама авторизовываться и возвращать в тест PageObject главной страницы.

#### Что было сделано:
* Настроено окружение для корректного запуска UI тестов:
  * добавлен марк -m UI
  * выбрана версия **105.0.5195.19** chromedriver 
  * добавлены входные аргументы в метод `pytest_addoption` 
  * настроены зависимости _requirements.txt_
  * реализована фикстура, которая авторизовывается и возвращает в тест **PageObject** главной страницы
  * добавлена поддержка параллельного запуска (библиотека `pytest-xdist`)
  * использован паттерн **PageObject**
  * добавлен файл _valid_creds.txt_ с валидными значения логина и пароля для авторизации
  * реализована генерация информативного отчета в allure (шаги, логи, скриншоты)


* Написаны тесты:
  * Класс **TestCampaign**:
    * `test_new_special_campaign` на создание и проверки рекламной кампании "Специальные возможности"
  * Класс **TestSegment**:
    * `test_new_game_app_segment` на создание и проверки сегмента в аудиториях с типом "Приложения и игры в соцсетях"
    * `test_vk_ok_segment_creation_deletion` на создание, проверки и удаления сегмента c источником данных группы VK образование, а также удаления самого источника данных
---
## Домашнее задание №3: Работа с API myTarget

#### Цель домашнего задания
 
  * Научиться делать то же самое, что и браузер, но самостоятельно через API-запросы.
    Работа с API идет без документации, просто по аналогии с тем, как работает браузер с запросами (на примере сущностей из ДЗ №2).
  * Научиться писать тесты с использованием библиотеки requests.

#### Задача
 * Тестирование портала https://target-sandbox.my.com
 * Настроить окружение для запуска API-тестов.
 * API-тесты должны запускаться через марк -m API.
 * Все тесты должны работать как минимум в 2 потока (через [pytest-xdist](https://pypi.org/project/pytest-xdist/) с аргументом -n 2).
 * Описание ДЗ (10 баллов):  
     * **Написать API клиент, который будет иметь возможность авторизовываться на портале (3 балла).**
     * Написать тест на работу с кампанией кампании любого типа через API: кампания должна быть создана, затем проверена, что она создана, после этого - удалена (2 балла).
       Все в рамках одного теста.
     * Написать тест на работу с сегментами в аудиториях через API : сегмент должен быть создаен, затем проверен, что он создался, после этого - удален (2 балл).
       Все в рамках одного теста.
     * Написать тест на создание сегмента, предварительно добавив в [источники данных](https://target-sandbox.my.com/segments/groups_list) группу [VK образования](https://vk.com/vkedu).
       После этого вам нужно создать сегмент (как и в пункте выше) с типом "Группы OK и VK", проверить, что он есть, а затем **удалить** именно этот сегмент и добавленный источник данных (3 балла)
#### Что было сделано:
* Настроено окружение для корректного запуска API тестов:
  * добавлен марк -m API
  * настроены зависимости _requirements.txt_
  * добавлена поддержка параллельного запуска (библиотека `pytest-xdist`)
  * добавлен файл _valid_creds.txt_ с валидными значения логина и пароля для авторизации
  * написан API клиент, который может авторизовываться на портале

* Написаны тесты:
  * Класс **TestCampaignApi**:
    * `test_campaign_creation_deletion` на создание, удаление и проверку рекламной кампании "Специальные возможности"
  * Класс **TestSegmentApi**:
    * параметризованный `test_segment_creation_deletion` на создание, удаление и проверку сегмента в аудиториях с типом "Приложения и игры в соцсетях"
    * параметризованный `test_vk_ok_source_segment_creation_deletion` на создание, удаление и проверку сегмента с источником данных группы "VK образование", а также проверку на удаление самого источника данных
---
## Домашнее задание №5: Backend: Linux

#### Цель домашнего задания

  - Анализировать nginx логи
  - Освоить написание bash скриптов в одну строчку
  - Научиться писать bash/python скрипты

#### Задача
##### Bash/Python scripting (максимум 6 баллов)
* Написать скрипты на **bash** и **python** для анализа [готового access.log](https://cloud.mail.ru/public/W2Bi/3NmgGtATH) (на python)
* Должен быть README.md файл, который описывает как работает каждый скрипт.
* Слово "запрос" далее означает конкретный location(path! внимательно прочитайте что это такое, буду душнить и снижать баллы), который был запрошен у сервера

* Для приложенного в задании access.log файла должна собираться следующая информация:
   * Общее количество запросов (1 балл)
   * Общее количество запросов по типу, например: GET - 20, POST - 10 и т.д. (1 балл)
   * Топ 10 самых частых запросов (1 балл): 
   
         должен выводиться url
         должно выводиться число запросов

   * Топ 5 самых больших по размеру запросов, которые завершились клиентской (4ХХ) ошибкой (1 балл):
    
         должен выводиться url
         должен выводиться статус код
         должен выводиться размер запроса
         должен выводиться ip адрес
         
   * Топ 5 пользователей по количеству запросов, которые завершились серверной (5ХХ) ошибкой (1 балл):
   
         должен выводиться ip адрес
         должно выводиться количество запросов

* Результаты нужно сохранять в произвольный файл (должен быть указан в README.md) в формате "какая информация собирается" <перенос строки> "результат"

* Дополнительное задание (1 балл):
   * Для Python скрипта реализовать возможность сохранять собранные данные в JSON (флаг запуска --json),
скруктура JSON произвольная
 
* Сделать выводы в чем минусы и плюсы решения на BASH и на PYTHON.
* Для тех кто дочитал, в Python части можно сделать только 2, 3 и 4 или 5 (3 в сумме) задания, рекомендую использовать библиотеку re

#### Что было сделано:
* Написан bash script:
  * `> result.txt` создает файл result.txt(далее файл)
  * `echo "Общее число запросов" >> result.txt` выводит в файл заголовок для первого результата
  * `wc -l < access.log >> result.txt` выводит в файл общее число строк (в данном случае это будут все запросы) без имени файла
  * `echo >>result.txt | echo "Общее количество запросов по типу" >> result.txt` выводит в файл заголовок для второго результата
  * `cat access.log | awk '{print $6}' | sort | uniq -c | sort -nr >> result.txt` из содержимого access.log выбираются методы по расположению в строке, которые затем сортируются, чтобы потом отсортировать их по уникальности в порядке убывания и в результате вывести в файл общее количество запросов по типу в виде: 
  
         число запросов тип запроса
  * `echo >>result.txt | echo "Топ 10 самых частых запросов" >> result.txt` выводит в файл заголовок для третьего результата
  * `cat access.log | cut -d " " -f 7  | sort | uniq -c | sort -nr | head -n 10  | awk '{print $2, "\n" $1}' >> result.txt
`  из содержимого access.log выбираются урлы по расположению в строке, которые затем сортируются, чтобы потом отсортировать их по уникальности в порядке убывания, выбираются только первые 10 строк и в конце настраивается порядок вывода в файл в виде:
    
         url
         число запросов
  * `echo >>result.txt | echo "Топ 5 самых больших по размеру запросов, которые завершились клиентской (4ХХ) ошибкой" >> result.txt
` выводит в файл заголовок для четвертого результата
  * `cat access.log | awk '$9 ~/4./' | sort -k10 -nr | head -n 5 | awk '{print $7, "\n" $9, "\n" $10, "\n" $1}'  >> result.txt
`  из содержимого access.log выбираются строки только с 4XX ошибками, которые потом сортируются по убыванию размера запроса, затем выбираются только первые 5 строк и в конце настраивается порядок вывода в файл в виде:

         url
         статус код
         размер запроса
         ip адрес
  * `echo >>result.txt | echo "Топ 5 пользователей по количеству запросов, которые завершились серверной (5ХХ) ошибкой" >> result.txt
` выводит в файл заголовок для пятого результата
  * `cat access.log | awk '$9 ~/5./' | awk '{print $1}' | uniq -c | sort -nr| head -n 5 | awk '{print $2, "\n" $1}' >> result.txt` 
из содержимого access.log выбираются строки только с 5XX ошибками, потом выбираются ip адреса, которые сортируются по количеству в порядке убывания, выбираются только первые 5 строк и в конце настраивается порядок вывода в файл в виде:
   
         ip адрес
         количество запросов
* Написан python script:
  * функция `top_methods` для вывода общего количества запросов по типу в файл `py_result.txt` (далее файл)
  * функция `top_reqs` для вывода топ 10 самых частых запросов в файл
  * функция `top_big_reqs` для вывода топ 5 самых больших по размеру запросов, которые завершились клиентской (4ХХ) ошибкой

#### Выводы:
Bash скрипты в одну строку мне показались намного удобнее для поиска необходимой информации в строках, так как в python скриптах приходится заморачиваться с открытием/чтением файла, всякими типами данных для сортировки нужной информации и т.д. 
Конечно python позволяет затем что угодно делать с полученными данными, но именно лаконичность bash скриптов мне кажется очень весомым плюсом.

